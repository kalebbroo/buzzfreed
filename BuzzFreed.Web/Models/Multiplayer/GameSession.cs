namespace BuzzFreed.Web.Models.Multiplayer;

/// <summary>
/// Represents an active game session once players leave lobby
///
/// LIFECYCLE:
/// 1. Created when host clicks "Start Game"
/// 2. Progresses through turns/rounds
/// 3. Ends when all questions answered or host ends early
/// 4. Results calculated and saved to database
///
/// ARCHITECTURE NOTES:
/// - Each session is tied to one GameRoom
/// - Session state is authoritative (server-side)
/// - Frontend syncs from session via real-time events
/// - Session includes full event log for replay functionality
///
/// TODO: Add pause/resume functionality
/// TODO: Add session recordings for highlight reels
/// </summary>
public class GameSession
{
    /// <summary>
    /// Unique identifier for this session
    /// </summary>
    public string SessionId { get; set; } = Guid.NewGuid().ToString();

    /// <summary>
    /// Room this session belongs to
    /// </summary>
    public string RoomId { get; set; } = string.Empty;

    /// <summary>
    /// Discord Guild ID for analytics
    /// </summary>
    public string GuildId { get; set; } = string.Empty;

    /// <summary>
    /// Game mode being played
    /// Determines rules, scoring, and flow
    /// </summary>
    public GameModeType GameMode { get; set; }

    /// <summary>
    /// Current quiz being played
    /// Generated by AI based on quiz settings
    /// </summary>
    public Quiz CurrentQuiz { get; set; } = new();

    /// <summary>
    /// Quiz customization settings
    /// Applied when generating quiz
    /// </summary>
    public QuizCustomization Settings { get; set; } = new();

    /// <summary>
    /// Current turn/round state
    /// Null when between turns or game ended
    /// </summary>
    public TurnState? CurrentTurn { get; set; }

    /// <summary>
    /// Overall session state
    /// </summary>
    public SessionState State { get; set; } = SessionState.Starting;

    /// <summary>
    /// List of all players in this session
    /// Snapshot from room at start time
    /// </summary>
    public List<Player> Players { get; set; } = new();

    /// <summary>
    /// List of spectators watching this session
    /// Spectators can join mid-game and interact (react, predict, etc.)
    /// </summary>
    public List<Player> Spectators { get; set; } = new();

    /// <summary>
    /// Maximum number of spectators allowed
    /// </summary>
    public int MaxSpectators { get; set; } = 50;

    /// <summary>
    /// Teams (if applicable)
    /// Null for non-team modes
    /// </summary>
    public Dictionary<string, Team>? Teams { get; set; }

    /// <summary>
    /// Current scores: PlayerId/TeamId â†’ Score
    /// Updated after each question
    /// </summary>
    public Dictionary<string, int> Scores { get; set; } = new();

    /// <summary>
    /// Full event log for this session
    /// Used for replays, analytics, debugging
    ///
    /// TODO: Limit size or move to separate storage
    /// TODO: Add event compression for long sessions
    /// </summary>
    public List<GameEvent> EventLog { get; set; } = new();

    /// <summary>
    /// Interaction history (reactions, suggestions, etc.)
    /// </summary>
    public List<Interaction> Interactions { get; set; } = new();

    /// <summary>
    /// Session statistics
    /// Aggregated from all turns
    /// </summary>
    public SessionStats Stats { get; set; } = new();

    /// <summary>
    /// When session was created
    /// </summary>
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    /// <summary>
    /// When session started (quiz generation complete)
    /// </summary>
    public DateTime? StartedAt { get; set; }

    /// <summary>
    /// When session ended
    /// </summary>
    public DateTime? EndedAt { get; set; }

    // Helper methods

    /// <summary>
    /// Start a new turn with given player/team
    /// </summary>
    public void StartTurn(string activePlayerId, int questionNumber)
    {
        CurrentTurn = new TurnState
        {
            TurnId = Guid.NewGuid().ToString(),
            SessionId = SessionId,
            ActivePlayerId = activePlayerId,
            QuestionNumber = questionNumber,
            Phase = TurnPhase.Question,
            StartTime = DateTime.UtcNow,
            TimeLimit = GetTimeLimitForMode()
        };

        LogEvent(new GameEvent
        {
            Type = GameEventType.TurnStarted,
            PlayerId = activePlayerId,
            Data = $"Question {questionNumber}"
        });
    }

    /// <summary>
    /// End current turn and calculate results
    /// </summary>
    public void EndTurn()
    {
        if (CurrentTurn == null) return;

        CurrentTurn.Phase = TurnPhase.Results;
        CurrentTurn.EndTime = DateTime.UtcNow;

        LogEvent(new GameEvent
        {
            Type = GameEventType.TurnEnded,
            PlayerId = CurrentTurn.ActivePlayerId,
            Data = $"Duration: {CurrentTurn.Duration.TotalSeconds:F1}s"
        });

        // TODO: Calculate turn score
        // TODO: Update player/team scores
        // TODO: Update statistics
    }

    /// <summary>
    /// Log a game event
    /// </summary>
    public void LogEvent(GameEvent gameEvent)
    {
        gameEvent.SessionId = SessionId;
        gameEvent.Timestamp = DateTime.UtcNow;
        EventLog.Add(gameEvent);
    }

    /// <summary>
    /// Get time limit based on game mode
    /// </summary>
    public int GetTimeLimitForMode()
    {
        return GameMode switch
        {
            GameModeType.SpeedRound => 10, // Fast!
            GameModeType.HotSeat => 30,
            GameModeType.TeamChallenge => 45, // More time for discussion
            GameModeType.Collaborative => 60,
            _ => 30
        };
    }

    /// <summary>
    /// Check if session is complete
    /// </summary>
    public bool IsComplete() =>
        CurrentTurn?.QuestionNumber >= CurrentQuiz.Questions.Count;

    /// <summary>
    /// Get next player in rotation
    /// </summary>
    public string GetNextPlayer()
    {
        if (CurrentTurn == null) return Players.First().UserId;

        int currentIndex = Players.FindIndex(p => p.UserId == CurrentTurn.ActivePlayerId);
        int nextIndex = (currentIndex + 1) % Players.Count;

        return Players[nextIndex].UserId;
    }

    // TODO: Add GetLeaderboard()
    // TODO: Add GetPlayerRank(playerId)
    // TODO: Add GetHighlightMoments() - funny/interesting events
    // TODO: Add ExportResults() for sharing

    // Spectator methods

    /// <summary>
    /// Check if spectator list is full
    /// </summary>
    public bool IsSpectatorsFull() => Spectators.Count >= MaxSpectators;

    /// <summary>
    /// Get spectator by user ID
    /// </summary>
    public Player? GetSpectator(string userId) =>
        Spectators.FirstOrDefault(s => s.UserId == userId);

    /// <summary>
    /// Check if user is a spectator
    /// </summary>
    public bool IsSpectator(string userId) =>
        Spectators.Any(s => s.UserId == userId);

    /// <summary>
    /// Check if user is in session (as player or spectator)
    /// </summary>
    public bool IsInSession(string userId) =>
        Players.Any(p => p.UserId == userId) || IsSpectator(userId);

    /// <summary>
    /// Add a spectator to the session
    /// </summary>
    public bool AddSpectator(Player spectator)
    {
        if (IsSpectatorsFull() || IsInSession(spectator.UserId))
            return false;

        spectator.Role = PlayerRole.Spectator;
        Spectators.Add(spectator);

        LogEvent(new GameEvent
        {
            Type = GameEventType.PlayerJoined,
            PlayerId = spectator.UserId,
            Data = "Joined as spectator"
        });

        return true;
    }

    /// <summary>
    /// Remove a spectator from the session
    /// </summary>
    public bool RemoveSpectator(string userId)
    {
        Player? spectator = GetSpectator(userId);
        if (spectator == null) return false;

        Spectators.Remove(spectator);

        LogEvent(new GameEvent
        {
            Type = GameEventType.PlayerLeft,
            PlayerId = userId,
            Data = "Spectator left"
        });

        return true;
    }

    /// <summary>
    /// Get all participants (players + spectators)
    /// </summary>
    public IEnumerable<Player> GetAllParticipants() =>
        Players.Concat(Spectators);

    /// <summary>
    /// Total participant count
    /// </summary>
    public int TotalParticipants => Players.Count + Spectators.Count;

    /// <summary>
    /// Current turn number for external reference
    /// </summary>
    public int CurrentTurnNumber => CurrentTurn?.QuestionNumber ?? 0;

    /// <summary>
    /// Total turns in the session
    /// </summary>
    public int TotalTurns => CurrentQuiz?.Questions?.Count ?? 0;
}

/// <summary>
/// Session lifecycle states
/// </summary>
public enum SessionState
{
    /// <summary>
    /// Session created, generating quiz
    /// </summary>
    Starting,

    /// <summary>
    /// Actively playing through questions
    /// </summary>
    Active,

    /// <summary>
    /// Paused (future feature)
    /// </summary>
    Paused,

    /// <summary>
    /// All questions answered, calculating final results
    /// </summary>
    Calculating,

    /// <summary>
    /// Session complete, showing results
    /// </summary>
    Completed,

    /// <summary>
    /// Session was aborted (host left, error, etc.)
    /// </summary>
    Aborted
}

/// <summary>
/// Session-wide statistics
/// Aggregated from all turns and players
/// </summary>
public class SessionStats
{
    public int TotalQuestions { get; set; } = 0;
    public int TotalAnswers { get; set; } = 0;
    public int TotalReactions { get; set; } = 0;
    public int TotalSuggestions { get; set; } = 0;

    public TimeSpan TotalDuration => EndTime.HasValue && StartTime.HasValue
        ? EndTime.Value - StartTime.Value
        : TimeSpan.Zero;

    public DateTime? StartTime { get; set; }
    public DateTime? EndTime { get; set; }

    public double AverageAnswerTime { get; set; } = 0;
    public string? FastestPlayer { get; set; }
    public string? MostAccuratePlayer { get; set; }
    public string? MostReactionsPlayer { get; set; }
    public string? FunniestAnswer { get; set; }

    // TODO: Add per-mode specific stats
    // TODO: Add "moment of the game"
    // TODO: Add AI-generated summary
}
